---
title: '强国学习--day2'
date: 2025-11-12
permalink: /posts/2025/11/blog-post-2/
tags:
  - donut
  - math
---

# 🍩 旋转甜甜圈

你吃过甜甜圈吗？屏幕正常都是显示二维图像，但是透过设定光线射入与反射可以使得我们的眼睛感受到三维立体的效果，通过数学我们可以将这一效果实现。

---

## 🧱 一、圆环的几何建模（Torus Geometry）

甜甜圈（圆环面）是一个小圆绕着一个大圆旋转形成的三维曲面。

设：

- 小圆半径：\\(R_1\\)（甜甜圈“管”的半径）
- 大圆半径：\\(R_2\\)（甜甜圈中心到管心的距离）
- 参数：
  - $$\theta$$：小圆角度（管的截面角度）
  - $$\phi$$：绕中心旋转角度

则三维参数方程为：

$$
\begin{aligned}
x &= (R_2 + R_1 \cos \theta)\cos \phi, \\
y &= (R_2 + R_1 \cos \theta)\sin \phi, \\
z &= R_1 \sin \theta.
\end{aligned}
$$

这些点 \\((x,y,z\\)) 构成了一个位于原点的圆环。

---

## 🧭 二、空间旋转 (3D Rotation)

为了让甜甜圈“原地旋转”，我们需要绕多个坐标轴进行旋转变换。

### 旋转矩阵：

- 绕 **X 轴**（前后翻滚）：
  $$
  R_x(A) =
  \begin{bmatrix}
  1 & 0 & 0 \\
  0 & \cos A & -\sin A \\
  0 & \sin A & \cos A
  \end{bmatrix}
  $$

- 绕 **Y 轴**（左右翻滚）：
  $$
  R_y(C) =
  \begin{bmatrix}
  \cos C & 0 & \sin C \\
  0 & 1 & 0 \\
  -\sin C & 0 & \cos C
  \end{bmatrix}
  $$

- 绕 **Z 轴**（自转）：
  $$
  R_z(B) =
  \begin{bmatrix}
  \cos B & -\sin B & 0 \\
  \sin B & \cos B & 0 \\
  0 & 0 & 1
  \end{bmatrix}
  $$

### 综合旋转：

按顺序将三次旋转作用于圆环点：

$$
\mathbf{r'} = R_z(B) \, R_y(C) \, R_x(A) \, \mathbf{r}
$$

这样甜甜圈就能在自身中心进行“前后 + 左右 + 自转”的复合旋转。

---

## 🎥 三、透视投影（Perspective Projection）

为了显示在屏幕上，需要将三维坐标 \\((x', y', z'\\)) 投影到二维平面上。

使用简单的透视投影模型：

$$
\begin{aligned}
x_p &= \frac{K_1 x'}{K_2 + z'}, \\
y_p &= \frac{K_1 y'}{K_2 + z'}.
\end{aligned}
$$

其中：

- \\(K_1\\) 控制缩放；
- \\(K_2\\) 控制视距；
- 当 \\(z'\\) 增大时，物体看起来更小，形成透视。

---

## 🧠 四、光照模型（Lighting Model）

该版本使用了一个固定方向的平行光源（例如来自 “右上前方”），采用**朗伯漫反射模型 (Lambertian Reflection)**：

### 1️⃣ 法向量（Normal Vector）

在“局部坐标系”中，圆环表面的法向量为：

$$
\mathbf{N} =
\begin{bmatrix}
\cos \phi \cos \theta \\
\sin \phi \cos \theta \\
\sin \theta
\end{bmatrix}
$$

它指向表面外侧的法线方向。

同样需要经过与点相同的旋转：

$$
\mathbf{N'} = R_z(B) \, R_y(C) \, R_x(A) \, \mathbf{N}
$$

---

### 2️⃣ 光源方向（Light Direction）

设光源方向为（单位向量）：

$$
\mathbf{L_s} = \frac{1}{\sqrt{3}}
\begin{bmatrix}
1 \\ 1 \\ -1
\end{bmatrix}
$$

即从右上前方照射。

---

### 3️⃣ 亮度计算（Lambert 光照）

表面亮度为法向量与光源方向的点积：

$$
L = \max(0, \mathbf{N'} \cdot \mathbf{L_s})
$$

取 $$\max(0, L)$$是为了忽略背面（光照不到的部分）。

---

## 💡 五、字符亮度映射（ASCII Brightness Mapping）

使用一组从“暗”到“亮”的字符进行亮度编码：
```js
.,-~:;=!*#$@
```

映射规则：

$$
\text{char\_index} = \lfloor L \times (N_{\text{chars}} - 1) \rfloor
$$

亮度越高的点选用更“实”的字符，形成视觉上的明暗层次。

---

## 🧮 六、深度排序（Z-buffer）

为保证近处字符遮挡远处字符，引入深度缓冲：

- 对每个像素位置 `(x_p, y_p)`，记录一个“逆深度”：
  $$
  \text{ooz} = \frac{1}{K_2 + z'}
  $$
- 若当前点的 `ooz` 大于之前的值，则更新该像素。

这样能正确处理“前面挡住后面”的视觉效果。

---

## 🌀 七、动画实现

在每一帧中，角度不断变化：

$$
\begin{aligned}
A &\leftarrow A + \Delta A, \\
B &\leftarrow B + \Delta B, \\
C &\leftarrow C + \Delta C,
\end{aligned}
$$

每 22ms（约 20 帧/秒）重新计算圆环点、亮度与字符矩阵，形成连续旋转。

---

## 🧩 八、完整流程概览

1. 建立参数化圆环；
2. 对每个点计算法线；
3. 将点与法线一起旋转（X、Y、Z 三轴）；
4. 投影到 2D；
5. 计算亮度；
6. 用字符映射亮度；
7. 用 z-buffer 确保遮挡；
8. 每帧更新角度。

---

## 🧬 关键数学总结

$$
\begin{aligned}
\mathbf{r} &= 
\begin{bmatrix}
(R_2 + R_1 \cos \theta)\cos \phi \\
(R_2 + R_1 \cos \theta)\sin \phi \\
R_1 \sin \theta
\end{bmatrix}, \\[6pt]
\mathbf{N} &= 
\begin{bmatrix}
\cos \phi \cos \theta \\
\sin \phi \cos \theta \\
\sin \theta
\end{bmatrix}, \\[6pt]
\mathbf{r'} &= R_z(B) R_y(C) R_x(A) \mathbf{r}, \\[6pt]
\mathbf{N'} &= R_z(B) R_y(C) R_x(A) \mathbf{N}, \\[6pt]
(x_p, y_p) &= \left(\frac{K_1 x'}{K_2 + z'}, \frac{K_1 y'}{K_2 + z'}\right), \\[6pt]
L &= \max(0, \mathbf{N'} \cdot \mathbf{L_s}).
\end{aligned}
$$

---

## 🔚 九、效果显示
![](/images/donut.gif)